{
    "sourceFile": "lib/bloc/draw/draw_bloc.dart",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 3,
            "patches": [
                {
                    "date": 1747190300337,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1747190328449,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -32,10 +32,9 @@\n       if (event.drawingName != null) {\r\n         final drawingData = _drawingBox.get(event.drawingName);\r\n         if (drawingData != null) {\r\n           final strokes = (drawingData['strokes'] as List)\r\n-              .map((s) => Stroke.fromPoints(\r\n-               as Map<dynamic, dynamic>))\r\n+              .map((s) => Stroke.fromJson(s as Map<String, dynamic>))\r\n               .toList();\r\n           final shapes = (drawingData['shapes'] as List)\r\n               .map((s) => Shape.fromJson(s as Map<String, dynamic>))\r\n               .toList();\r\n"
                },
                {
                    "date": 1747190601790,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,192 +1,121 @@\n-import 'dart:convert';\r\n import 'dart:typed_data';\r\n-import 'package:bloc/bloc.dart';\r\n-import 'package:drawing/draw/model/offset.dart';\r\n-import 'package:drawing/draw/model/shape.dart';\r\n-import 'package:drawing/draw/model/stroke.dart';\r\n-import 'package:drawing/draw/model/thumbnail.dart';\r\n+import 'package:flutter_bloc/flutter_bloc.dart';\r\n import 'package:equatable/equatable.dart';\r\n-import 'package:flutter/material.dart';\r\n import 'package:hive_flutter/hive_flutter.dart';\r\n-import 'package:image/image.dart' as img;\r\n-import 'package:image_picker/image_picker.dart';\r\n-import 'package:path_provider/path_provider.dart';\r\n-import 'dart:io';\r\n-import 'package:uuid/uuid.dart';\r\n+import '../../draw/model/stroke.dart';\r\n+import '../../draw/model/shape.dart';\r\n \r\n part 'draw_event.dart';\r\n part 'draw_state.dart';\r\n \r\n class DrawBloc extends Bloc<DrawEvent, DrawState> {\r\n-  final Box<Map<dynamic, dynamic>> _drawingBox;\r\n-  final Box<Thumbnail> _thumbnailBox;\r\n+  late Box<Map<dynamic, dynamic>> _drawingBox;\r\n \r\n-  DrawBloc()\r\n-      : _drawingBox = Hive.box<Map<dynamic, dynamic>>('drawings'),\r\n-        _thumbnailBox = Hive.box<Thumbnail>('thumbnails'),\r\n-        super(DrawInitial()) {\r\n+  DrawBloc() : super(DrawInitial()) {\r\n     on<InitializeDraw>(_onInitializeDraw);\r\n-    on<StartDrawing>(_onStartDrawing);\r\n-    on<UpdateDrawing>(_onUpdateDrawing);\r\n-    on<EndDrawing>(_onEndDrawing);\r\n+    on<AddStroke>(_onAddStroke);\r\n+    on<AddShape>(_onAddShape);\r\n     on<Undo>(_onUndo);\r\n     on<Redo>(_onRedo);\r\n     on<ClearCanvas>(_onClearCanvas);\r\n     on<SaveDrawing>(_onSaveDrawing);\r\n-    on<UpdateBrushSize>(_onUpdateBrushSize);\r\n-    on<UpdateColor>(_onUpdateColor);\r\n-    on<ToggleEraser>(_onToggleEraser);\r\n-    on<SelectShape>(_onSelectShape);\r\n   }\r\n \r\n   Future<void> _onInitializeDraw(\r\n     InitializeDraw event,\r\n     Emitter<DrawState> emit,\r\n   ) async {\r\n-    emit(DrawLoading());\r\n     try {\r\n+      emit(DrawLoading());\r\n+      _drawingBox = Hive.box<Map<dynamic, dynamic>>('drawingBox');\r\n+\r\n       if (event.drawingName != null) {\r\n         final drawingData = _drawingBox.get(event.drawingName);\r\n         if (drawingData != null) {\r\n           final strokes = (drawingData['strokes'] as List)\r\n-              .map((s) => Stroke.fromJson(s))\r\n+              .map((s) => Stroke.fromJson(s as Map<String, dynamic>))\r\n               .toList();\r\n           final shapes = (drawingData['shapes'] as List)\r\n-              .map((s) => Shape.fromJson(s))\r\n+              .map((s) => Shape.fromJson(s as Map<String, dynamic>))\r\n               .toList();\r\n           emit(DrawLoaded(\r\n             strokes: strokes,\r\n             shapes: shapes,\r\n             undoStrokes: [],\r\n             undoShapes: [],\r\n             drawingName: event.drawingName,\r\n           ));\r\n+          return;\r\n         }\r\n-      } else {\r\n-        emit(const DrawLoaded(\r\n-          strokes: [],\r\n-          shapes: [],\r\n-          undoStrokes: [],\r\n-          undoShapes: [],\r\n-        ));\r\n       }\r\n+\r\n+      emit(DrawLoaded(\r\n+        strokes: [],\r\n+        shapes: [],\r\n+        undoStrokes: [],\r\n+        undoShapes: [],\r\n+        drawingName: event.drawingName,\r\n+      ));\r\n     } catch (e) {\r\n       emit(DrawError(e.toString()));\r\n     }\r\n   }\r\n \r\n-  void _onStartDrawing(\r\n-    StartDrawing event,\r\n+  void _onAddStroke(\r\n+    AddStroke event,\r\n     Emitter<DrawState> emit,\r\n   ) {\r\n     if (state is DrawLoaded) {\r\n       final currentState = state as DrawLoaded;\r\n-      if (event.shapeType != null) {\r\n-        emit(currentState.copyWith(\r\n-          startPoint: event.position,\r\n-          isDrawingShape: true,\r\n-          selectedShapeType: event.shapeType,\r\n-        ));\r\n-      } else {\r\n-        emit(currentState.copyWith(\r\n-          currentPoints: [event.position],\r\n-        ));\r\n-      }\r\n+      final newStrokes = List<Stroke>.from(currentState.strokes)..add(event.stroke);\r\n+      emit(currentState.copyWith(\r\n+        strokes: newStrokes,\r\n+        undoStrokes: [],\r\n+        undoShapes: [],\r\n+      ));\r\n     }\r\n   }\r\n \r\n-  void _onUpdateDrawing(\r\n-    UpdateDrawing event,\r\n+  void _onAddShape(\r\n+    AddShape event,\r\n     Emitter<DrawState> emit,\r\n   ) {\r\n     if (state is DrawLoaded) {\r\n       final currentState = state as DrawLoaded;\r\n-      if (currentState.isDrawingShape) {\r\n-        emit(currentState.copyWith(\r\n-          endPoint: event.position,\r\n-        ));\r\n-      } else {\r\n-        final updatedPoints = List<Offset>.from(currentState.currentPoints)\r\n-          ..add(event.position);\r\n-        emit(currentState.copyWith(\r\n-          currentPoints: updatedPoints,\r\n-        ));\r\n-      }\r\n+      final newShapes = List<Shape>.from(currentState.shapes)..add(event.shape);\r\n+      emit(currentState.copyWith(\r\n+        shapes: newShapes,\r\n+        undoStrokes: [],\r\n+        undoShapes: [],\r\n+      ));\r\n     }\r\n   }\r\n \r\n-  void _onEndDrawing(\r\n-    EndDrawing event,\r\n-    Emitter<DrawState> emit,\r\n-  ) {\r\n-    if (state is DrawLoaded) {\r\n-      final currentState = state as DrawLoaded;\r\n-      if (currentState.isDrawingShape && currentState.startPoint != null) {\r\n-        final shape = Shape(\r\n-          type: event.shapeType,\r\n-          startPoint: OffsetCustom(\r\n-            dx: currentState.startPoint!.dx,\r\n-            dy: currentState.startPoint!.dy,\r\n-          ),\r\n-          endPoint: OffsetCustom(\r\n-            dx: event.position.dx,\r\n-            dy: event.position.dy,\r\n-          ),\r\n-          color: event.color,\r\n-          strokeWidth: event.brushSize,\r\n-        );\r\n-        final updatedShapes = List<Shape>.from(currentState.shapes)..add(shape);\r\n-        emit(currentState.copyWith(\r\n-          shapes: updatedShapes,\r\n-          startPoint: null,\r\n-          endPoint: null,\r\n-          isDrawingShape: false,\r\n-        ));\r\n-      } else {\r\n-        final stroke = Stroke(\r\n-          points: currentState.currentPoints\r\n-              .map((p) => OffsetCustom(dx: p.dx, dy: p.dy))\r\n-              .toList(),\r\n-          color: event.color,\r\n-          brushSize: event.brushSize,\r\n-        );\r\n-        final updatedStrokes = List<Stroke>.from(currentState.strokes)\r\n-          ..add(stroke);\r\n-        emit(currentState.copyWith(\r\n-          strokes: updatedStrokes,\r\n-          currentPoints: [],\r\n-        ));\r\n-      }\r\n-    }\r\n-  }\r\n-\r\n   void _onUndo(\r\n     Undo event,\r\n     Emitter<DrawState> emit,\r\n   ) {\r\n     if (state is DrawLoaded) {\r\n       final currentState = state as DrawLoaded;\r\n-      if (currentState.strokes.isNotEmpty) {\r\n-        final lastStroke = currentState.strokes.last;\r\n-        final updatedStrokes = List<Stroke>.from(currentState.strokes)\r\n-          ..removeLast();\r\n-        final updatedUndoStrokes = List<Stroke>.from(currentState.undoStrokes)\r\n-          ..add(lastStroke);\r\n+      if (currentState.strokes.isNotEmpty || currentState.shapes.isNotEmpty) {\r\n+        final newStrokes = List<Stroke>.from(currentState.strokes);\r\n+        final newShapes = List<Shape>.from(currentState.shapes);\r\n+        final newUndoStrokes = List<Stroke>.from(currentState.undoStrokes);\r\n+        final newUndoShapes = List<Shape>.from(currentState.undoShapes);\r\n+\r\n+        if (newStrokes.isNotEmpty) {\r\n+          newUndoStrokes.add(newStrokes.removeLast());\r\n+        } else if (newShapes.isNotEmpty) {\r\n+          newUndoShapes.add(newShapes.removeLast());\r\n+        }\r\n+\r\n         emit(currentState.copyWith(\r\n-          strokes: updatedStrokes,\r\n-          undoStrokes: updatedUndoStrokes,\r\n+          strokes: newStrokes,\r\n+          shapes: newShapes,\r\n+          undoStrokes: newUndoStrokes,\r\n+          undoShapes: newUndoShapes,\r\n         ));\r\n-      } else if (currentState.shapes.isNotEmpty) {\r\n-        final lastShape = currentState.shapes.last;\r\n-        final updatedShapes = List<Shape>.from(currentState.shapes)\r\n-          ..removeLast();\r\n-        final updatedUndoShapes = List<Shape>.from(currentState.undoShapes)\r\n-          ..add(lastShape);\r\n-        emit(currentState.copyWith(\r\n-          shapes: updatedShapes,\r\n-          undoShapes: updatedUndoShapes,\r\n-        ));\r\n       }\r\n     }\r\n   }\r\n \r\n@@ -195,28 +124,26 @@\n     Emitter<DrawState> emit,\r\n   ) {\r\n     if (state is DrawLoaded) {\r\n       final currentState = state as DrawLoaded;\r\n-      if (currentState.undoStrokes.isNotEmpty) {\r\n-        final lastUndoStroke = currentState.undoStrokes.last;\r\n-        final updatedStrokes = List<Stroke>.from(currentState.strokes)\r\n-          ..add(lastUndoStroke);\r\n-        final updatedUndoStrokes = List<Stroke>.from(currentState.undoStrokes)\r\n-          ..removeLast();\r\n+      if (currentState.undoStrokes.isNotEmpty || currentState.undoShapes.isNotEmpty) {\r\n+        final newStrokes = List<Stroke>.from(currentState.strokes);\r\n+        final newShapes = List<Shape>.from(currentState.shapes);\r\n+        final newUndoStrokes = List<Stroke>.from(currentState.undoStrokes);\r\n+        final newUndoShapes = List<Shape>.from(currentState.undoShapes);\r\n+\r\n+        if (newUndoStrokes.isNotEmpty) {\r\n+          newStrokes.add(newUndoStrokes.removeLast());\r\n+        } else if (newUndoShapes.isNotEmpty) {\r\n+          newShapes.add(newUndoShapes.removeLast());\r\n+        }\r\n+\r\n         emit(currentState.copyWith(\r\n-          strokes: updatedStrokes,\r\n-          undoStrokes: updatedUndoStrokes,\r\n+          strokes: newStrokes,\r\n+          shapes: newShapes,\r\n+          undoStrokes: newUndoStrokes,\r\n+          undoShapes: newUndoShapes,\r\n         ));\r\n-      } else if (currentState.undoShapes.isNotEmpty) {\r\n-        final lastUndoShape = currentState.undoShapes.last;\r\n-        final updatedShapes = List<Shape>.from(currentState.shapes)\r\n-          ..add(lastUndoShape);\r\n-        final updatedUndoShapes = List<Shape>.from(currentState.undoShapes)\r\n-          ..removeLast();\r\n-        emit(currentState.copyWith(\r\n-          shapes: updatedShapes,\r\n-          undoShapes: updatedUndoShapes,\r\n-        ));\r\n       }\r\n     }\r\n   }\r\n \r\n@@ -238,69 +165,20 @@\n   Future<void> _onSaveDrawing(\r\n     SaveDrawing event,\r\n     Emitter<DrawState> emit,\r\n   ) async {\r\n-    if (state is DrawLoaded) {\r\n-      final currentState = state as DrawLoaded;\r\n-      try {\r\n+    try {\r\n+      if (state is DrawLoaded) {\r\n+        final currentState = state as DrawLoaded;\r\n         final drawingData = {\r\n           'strokes': currentState.strokes.map((s) => s.toJson()).toList(),\r\n           'shapes': currentState.shapes.map((s) => s.toJson()).toList(),\r\n+          'thumbnail': event.thumbnail,\r\n         };\r\n-\r\n-        await _drawingBox.put(event.name, drawingData);\r\n-\r\n-        if (event.thumbnail != null) {\r\n-          final thumbnail = Thumbnail(\r\n-            name: event.name,\r\n-            imageBytes: event.thumbnail!,\r\n-          );\r\n-          await _thumbnailBox.put(event.name, thumbnail);\r\n-        }\r\n-\r\n-        emit(currentState.copyWith(drawingName: event.name));\r\n-      } catch (e) {\r\n-        emit(DrawError(e.toString()));\r\n+        await _drawingBox.put(event.drawingName, drawingData);\r\n+        emit(currentState.copyWith(drawingName: event.drawingName));\r\n       }\r\n+    } catch (e) {\r\n+      emit(DrawError(e.toString()));\r\n     }\r\n   }\r\n-\r\n-  void _onUpdateBrushSize(\r\n-    UpdateBrushSize event,\r\n-    Emitter<DrawState> emit,\r\n-  ) {\r\n-    if (state is DrawLoaded) {\r\n-      final currentState = state as DrawLoaded;\r\n-      emit(currentState.copyWith(brushSize: event.size));\r\n-    }\r\n-  }\r\n-\r\n-  void _onUpdateColor(\r\n-    UpdateColor event,\r\n-    Emitter<DrawState> emit,\r\n-  ) {\r\n-    if (state is DrawLoaded) {\r\n-      final currentState = state as DrawLoaded;\r\n-      emit(currentState.copyWith(selectedColor: event.color));\r\n-    }\r\n-  }\r\n-\r\n-  void _onToggleEraser(\r\n-    ToggleEraser event,\r\n-    Emitter<DrawState> emit,\r\n-  ) {\r\n-    if (state is DrawLoaded) {\r\n-      final currentState = state as DrawLoaded;\r\n-      emit(currentState.copyWith(isErasing: !currentState.isErasing));\r\n-    }\r\n-  }\r\n-\r\n-  void _onSelectShape(\r\n-    SelectShape event,\r\n-    Emitter<DrawState> emit,\r\n-  ) {\r\n-    if (state is DrawLoaded) {\r\n-      final currentState = state as DrawLoaded;\r\n-      emit(currentState.copyWith(selectedShapeType: event.shapeType));\r\n-    }\r\n-  }\r\n-}\r\n+} \n\\ No newline at end of file\n"
                },
                {
                    "date": 1747314351446,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,13 +1,228 @@\n-import 'package:bloc/bloc.dart';\n-import 'package:equatable/equatable.dart';\n+import 'dart:io';\n+import 'dart:typed_data';\n+import 'package:flutter_bloc/flutter_bloc.dart';\n+import 'package:hive/hive.dart';\n+import 'package:path_provider/path_provider.dart';\n+import 'package:drawing/draw/model/stroke.dart';\n+import 'package:drawing/draw/model/shape.dart';\n+import 'package:drawing/draw/model/thumbnail.dart';\n+import 'draw_event.dart';\n+import 'draw_state.dart';\n \n-part 'draw_event.dart';\n-part 'draw_state.dart';\n+class DrawBloc extends Bloc<DrawEvent, DrawState> {\n+  final Box<Map<dynamic, dynamic>> drawingBox;\n \n-class DrawBloc extends Bloc<DrawEvent, DrawState> {\n-  DrawBloc() : super(DrawInitial()) {\n-    on<DrawEvent>((event, emit) {\n-      // TODO: implement event handler\n+  DrawBloc(this.drawingBox) : super(const DrawState()) {\n+    on<LoadDrawing>(_onLoadDrawing);\n+    on<StartDrawingStroke>(_onStartDrawingStroke);\n+    on<UpdateDrawingStroke>(_onUpdateDrawingStroke);\n+    on<EndDrawingStroke>(_onEndDrawingStroke);\n+    on<StartDrawingShape>(_onStartDrawingShape);\n+    on<UpdateDrawingShape>(_onUpdateDrawingShape);\n+    on<EndDrawingShape>(_onEndDrawingShape);\n+    on<Undo>(_onUndo);\n+    on<Redo>(_onRedo);\n+    on<ChangeColor>(_onChangeColor);\n+    on<ChangeBrushSize>(_onChangeBrushSize);\n+    on<ToggleEraser>(_onToggleEraser);\n+    on<SelectShapeType>(_onSelectShapeType);\n+    on<SaveDrawing>(_onSaveDrawing);\n+    on<DownloadDrawing>(_onDownloadDrawing);\n+  }\n+\n+  Future<void> _onLoadDrawing(LoadDrawing event, Emitter<DrawState> emit) async {\n+    emit(state.copyWith(isLoading: true));\n+    if (event.drawingName != null) {\n+      final drawing = drawingBox.get(event.drawingName);\n+      if (drawing != null) {\n+        emit(state.copyWith(\n+          strokes: (drawing['strokes'] as List<dynamic>?)?.cast<Stroke>() ?? [],\n+          shapes: (drawing['shapes'] as List<dynamic>?)?.cast<Shape>() ?? [],\n+          drawingName: event.drawingName,\n+          isLoading: false,\n+        ));\n+      } else {\n+        emit(state.copyWith(\n+          isLoading: false,\n+          message: 'Không tìm thấy bản vẽ',\n+        ));\n+      }\n+    } else {\n+      emit(state.copyWith(isLoading: false));\n+    }\n+  }\n+\n+  void _onStartDrawingStroke(\n+      StartDrawingStroke event, Emitter<DrawState> emit) {\n+    if (state.selectedShapeType == null) {\n+      emit(state.copyWith(\n+        currentPoints: [...state.currentPoints, event.position],\n+      ));\n+    }\n+  }\n+\n+  void _onUpdateDrawingStroke(\n+      UpdateDrawingStroke event, Emitter<DrawState> emit) {\n+    if (state.selectedShapeType == null) {\n+      emit(state.copyWith(\n+        currentPoints: [...state.currentPoints, event.position],\n+      ));\n+    }\n+  }\n+\n+  void _onEndDrawingStroke(EndDrawingStroke event, Emitter<DrawState> emit) {\n+    if (state.currentPoints.isNotEmpty) {\n+      final newStroke = Stroke.fromPoints(\n+        points: List.from(state.currentPoints),\n+        brushSize: state.brushSize,\n+        color: state.isErasing ? Colors.white : state.selectedColor,\n+      );\n+      emit(state.copyWith(\n+        strokes: [...state.strokes, newStroke],\n+        currentPoints: [],\n+        redoStrokes: [],\n+      ));\n+    }\n+  }\n+\n+  void _onStartDrawingShape(\n+      StartDrawingShape event, Emitter<DrawState> emit) {\n+    if (state.selectedShapeType != null) {\n+      emit(state.copyWith(\n+        startPoint: event.position,\n+        endPoint: event.position,\n+        isDrawingShape: true,\n+      ));\n+    }\n+  }\n+\n+  void _onUpdateDrawingShape(\n+      UpdateDrawingShape event, Emitter<DrawState> emit) {\n+    if (state.isDrawingShape) {\n+      emit(state.copyWith(\n+        endPoint: event.position,\n+      ));\n+    }\n+  }\n+\n+  void _onEndDrawingShape(EndDrawingShape event, Emitter<DrawState> emit) {\n+    if (state.isDrawingShape &&\n+        state.startPoint != null &&\n+        state.endPoint != null) {\n+      final newShape = Shape(\n+        type: state.selectedShapeType!,\n+        startPoint: state.startPoint!,\n+        endPoint: state.endPoint!,\n+        color: state.selectedColor,\n+        strokeWidth: state.brushSize,\n+      );\n+      emit(state.copyWith(\n+        shapes: [...state.shapes, newShape],\n+        isDrawingShape: false,\n+        startPoint: null,\n+        endPoint: null,\n+        redoShapes: [],\n+      ));\n+    }\n+  }\n+\n+  void _onUndo(Undo event, Emitter<DrawState> emit) {\n+    if (state.strokes.isNotEmpty) {\n+      final lastStroke = state.strokes.last;\n+      emit(state.copyWith(\n+        strokes: state.strokes.sublist(0, state.strokes.length - 1),\n+        redoStrokes: [...state.redoStrokes, lastStroke],\n+      ));\n+    } else if (state.shapes.isNotEmpty) {\n+      final lastShape = state.shapes.last;\n+      emit(state.copyWith(\n+        shapes: state.shapes.sublist(0, state.shapes.length - 1),\n+        redoShapes: [...state.redoShapes, lastShape],\n+      ));\n+    }\n+  }\n+\n+  void _onRedo(Redo event, Emitter<DrawState> emit) {\n+    if (state.redoStrokes.isNotEmpty) {\n+      final lastRedoStroke = state.redoStrokes.last;\n+      emit(state.copyWith(\n+        strokes: [...state.strokes, lastRedoStroke],\n+        redoStrokes: state.redoStrokes.sublist(0, state.redoStrokes.length - 1),\n+      ));\n+    } else if (state.redoShapes.isNotEmpty) {\n+      final lastRedoShape = state.redoShapes.last;\n+      emit(state.copyWith(\n+        shapes: [...state.shapes, lastRedoShape],\n+        redoShapes: state.redoShapes.sublist(0, state.redoShapes.length - 1),\n+      ));\n+    }\n+  }\n+\n+  void _onChangeColor(ChangeColor event, Emitter<DrawState> emit) {\n+    emit(state.copyWith(\n+      selectedColor: event.color,\n+      isErasing: false,\n+    ));\n+  }\n+\n+  void _onChangeBrushSize(ChangeBrushSize event, Emitter<DrawState> emit) {\n+    emit(state.copyWith(brushSize: event.size));\n+  }\n+\n+  void _onToggleEraser(ToggleEraser event, Emitter<DrawState> emit) {\n+    emit(state.copyWith(\n+      isErasing: !state.isErasing,\n+      selectedShapeType: state.isErasing ? null : state.selectedShapeType,\n+    ));\n+  }\n+\n+  void _onSelectShapeType(SelectShapeType event, Emitter<DrawState> emit) {\n+    emit(state.copyWith(\n+      selectedShapeType: event.shapeType,\n+      isErasing: false,\n+    ));\n+  }\n+\n+  Future<void> _onSaveDrawing(SaveDrawing event, Emitter<DrawState> emit) async {\n+    emit(state.copyWith(isLoading: true));\n+    final thumbnail =\n+        await generateThumbnail(state.strokes, state.shapes, 200, 200);\n+    await drawingBox.put(event.name, {\n+      'strokes': state.strokes,\n+      'shapes': state.shapes,\n+      'thumbnail': thumbnail,\n     });\n+    emit(state.copyWith(\n+      drawingName: event.name,\n+      isLoading: false,\n+      message: 'Drawing saved successfully!',\n+    ));\n   }\n-}\n+\n+  Future<void> _onDownloadDrawing(\n+      DownloadDrawing event, Emitter<DrawState> emit) async {\n+    if (state.strokes.isEmpty && state.shapes.isEmpty) {\n+      emit(state.copyWith(message: 'Bạn chưa vẽ gì để tải về!'));\n+      return;\n+    }\n+\n+    try {\n+      final imageData =\n+          await generateThumbnail(state.strokes, state.shapes, 800, 800);\n+      if (imageData == null) {\n+        emit(state.copyWith(message: 'Không thể tạo hình ảnh'));\n+        return;\n+      }\n+\n+      final directory = await getExternalStorageDirectory();\n+      final filePath =\n+          '${directory!.path}/drawing_${DateTime.now().millisecondsSinceEpoch}.png';\n+      final file = File(filePath);\n+      await file.writeAsBytes(imageData);\n+\n+      emit(state.copyWith(message: 'Bản vẽ đã được lưu tại: $filePath'));\n+    } catch (e) {\n+      emit(state.copyWith(message: 'Lỗi khi lưu bản vẽ: $e'));\n+    }\n+  }\n+}\n\\ No newline at end of file\n"
                }
            ],
            "date": 1747190300337,
            "name": "Commit-0",
            "content": "import 'dart:typed_data';\r\nimport 'package:flutter_bloc/flutter_bloc.dart';\r\nimport 'package:equatable/equatable.dart';\r\nimport 'package:hive_flutter/hive_flutter.dart';\r\nimport '../../draw/model/stroke.dart';\r\nimport '../../draw/model/shape.dart';\r\n\r\npart 'draw_event.dart';\r\npart 'draw_state.dart';\r\n\r\nclass DrawBloc extends Bloc<DrawEvent, DrawState> {\r\n  late Box<Map<dynamic, dynamic>> _drawingBox;\r\n\r\n  DrawBloc() : super(DrawInitial()) {\r\n    on<InitializeDraw>(_onInitializeDraw);\r\n    on<AddStroke>(_onAddStroke);\r\n    on<AddShape>(_onAddShape);\r\n    on<Undo>(_onUndo);\r\n    on<Redo>(_onRedo);\r\n    on<ClearCanvas>(_onClearCanvas);\r\n    on<SaveDrawing>(_onSaveDrawing);\r\n  }\r\n\r\n  Future<void> _onInitializeDraw(\r\n    InitializeDraw event,\r\n    Emitter<DrawState> emit,\r\n  ) async {\r\n    try {\r\n      emit(DrawLoading());\r\n      _drawingBox = Hive.box<Map<dynamic, dynamic>>('drawingBox');\r\n\r\n      if (event.drawingName != null) {\r\n        final drawingData = _drawingBox.get(event.drawingName);\r\n        if (drawingData != null) {\r\n          final strokes = (drawingData['strokes'] as List)\r\n              .map((s) => Stroke.fromPoints(\r\n               as Map<dynamic, dynamic>))\r\n              .toList();\r\n          final shapes = (drawingData['shapes'] as List)\r\n              .map((s) => Shape.fromJson(s as Map<String, dynamic>))\r\n              .toList();\r\n          emit(DrawLoaded(\r\n            strokes: strokes,\r\n            shapes: shapes,\r\n            undoStrokes: [],\r\n            undoShapes: [],\r\n            drawingName: event.drawingName,\r\n          ));\r\n          return;\r\n        }\r\n      }\r\n\r\n      emit(DrawLoaded(\r\n        strokes: [],\r\n        shapes: [],\r\n        undoStrokes: [],\r\n        undoShapes: [],\r\n        drawingName: event.drawingName,\r\n      ));\r\n    } catch (e) {\r\n      emit(DrawError(e.toString()));\r\n    }\r\n  }\r\n\r\n  void _onAddStroke(\r\n    AddStroke event,\r\n    Emitter<DrawState> emit,\r\n  ) {\r\n    if (state is DrawLoaded) {\r\n      final currentState = state as DrawLoaded;\r\n      final newStrokes = List<Stroke>.from(currentState.strokes)..add(event.stroke);\r\n      emit(currentState.copyWith(\r\n        strokes: newStrokes,\r\n        undoStrokes: [],\r\n        undoShapes: [],\r\n      ));\r\n    }\r\n  }\r\n\r\n  void _onAddShape(\r\n    AddShape event,\r\n    Emitter<DrawState> emit,\r\n  ) {\r\n    if (state is DrawLoaded) {\r\n      final currentState = state as DrawLoaded;\r\n      final newShapes = List<Shape>.from(currentState.shapes)..add(event.shape);\r\n      emit(currentState.copyWith(\r\n        shapes: newShapes,\r\n        undoStrokes: [],\r\n        undoShapes: [],\r\n      ));\r\n    }\r\n  }\r\n\r\n  void _onUndo(\r\n    Undo event,\r\n    Emitter<DrawState> emit,\r\n  ) {\r\n    if (state is DrawLoaded) {\r\n      final currentState = state as DrawLoaded;\r\n      if (currentState.strokes.isNotEmpty || currentState.shapes.isNotEmpty) {\r\n        final newStrokes = List<Stroke>.from(currentState.strokes);\r\n        final newShapes = List<Shape>.from(currentState.shapes);\r\n        final newUndoStrokes = List<Stroke>.from(currentState.undoStrokes);\r\n        final newUndoShapes = List<Shape>.from(currentState.undoShapes);\r\n\r\n        if (newStrokes.isNotEmpty) {\r\n          newUndoStrokes.add(newStrokes.removeLast());\r\n        } else if (newShapes.isNotEmpty) {\r\n          newUndoShapes.add(newShapes.removeLast());\r\n        }\r\n\r\n        emit(currentState.copyWith(\r\n          strokes: newStrokes,\r\n          shapes: newShapes,\r\n          undoStrokes: newUndoStrokes,\r\n          undoShapes: newUndoShapes,\r\n        ));\r\n      }\r\n    }\r\n  }\r\n\r\n  void _onRedo(\r\n    Redo event,\r\n    Emitter<DrawState> emit,\r\n  ) {\r\n    if (state is DrawLoaded) {\r\n      final currentState = state as DrawLoaded;\r\n      if (currentState.undoStrokes.isNotEmpty || currentState.undoShapes.isNotEmpty) {\r\n        final newStrokes = List<Stroke>.from(currentState.strokes);\r\n        final newShapes = List<Shape>.from(currentState.shapes);\r\n        final newUndoStrokes = List<Stroke>.from(currentState.undoStrokes);\r\n        final newUndoShapes = List<Shape>.from(currentState.undoShapes);\r\n\r\n        if (newUndoStrokes.isNotEmpty) {\r\n          newStrokes.add(newUndoStrokes.removeLast());\r\n        } else if (newUndoShapes.isNotEmpty) {\r\n          newShapes.add(newUndoShapes.removeLast());\r\n        }\r\n\r\n        emit(currentState.copyWith(\r\n          strokes: newStrokes,\r\n          shapes: newShapes,\r\n          undoStrokes: newUndoStrokes,\r\n          undoShapes: newUndoShapes,\r\n        ));\r\n      }\r\n    }\r\n  }\r\n\r\n  void _onClearCanvas(\r\n    ClearCanvas event,\r\n    Emitter<DrawState> emit,\r\n  ) {\r\n    if (state is DrawLoaded) {\r\n      final currentState = state as DrawLoaded;\r\n      emit(currentState.copyWith(\r\n        strokes: [],\r\n        shapes: [],\r\n        undoStrokes: [],\r\n        undoShapes: [],\r\n      ));\r\n    }\r\n  }\r\n\r\n  Future<void> _onSaveDrawing(\r\n    SaveDrawing event,\r\n    Emitter<DrawState> emit,\r\n  ) async {\r\n    try {\r\n      if (state is DrawLoaded) {\r\n        final currentState = state as DrawLoaded;\r\n        final drawingData = {\r\n          'strokes': currentState.strokes.map((s) => s.toJson()).toList(),\r\n          'shapes': currentState.shapes.map((s) => s.toJson()).toList(),\r\n          'thumbnail': event.thumbnail,\r\n        };\r\n        await _drawingBox.put(event.drawingName, drawingData);\r\n        emit(currentState.copyWith(drawingName: event.drawingName));\r\n      }\r\n    } catch (e) {\r\n      emit(DrawError(e.toString()));\r\n    }\r\n  }\r\n} "
        }
    ]
}